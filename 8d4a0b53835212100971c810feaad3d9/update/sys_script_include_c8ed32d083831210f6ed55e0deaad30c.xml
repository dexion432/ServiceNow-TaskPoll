<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_376096_tpoll.PollUtil</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>PollUtil</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global Class, gs, sn_cc, sn_ws, x_376096_tpoll */
/* global GlideRecord */
/* eslint no-undef: "error" */
/*
var PreparedReq = Class.create();
PreparedReq.prototype = {
	initialize: function({ 
		id,
		headers,
		url,
		method,
    callback
	}) {
		this.id = id;
		this.headers = headers;
		this.url = url;
		this.method = method;
    this.callback = callback;
	}
};*/
var PollUtil = Class.create();
PollUtil.syncAll = function() {
    const aliasGr = new GlideRecord('sys_alias');
    aliasGr.addQuery('parent.id', 'x_376096_tpoll.tpoll');
    aliasGr.query();
    while (aliasGr.next()) {
        const pollUtil = new x_376096_tpoll.PollUtil(aliasGr.getUniqueValue());
        /*
        const incidents = pollUtil.getRecords({
        	table: 'incident'
        });

        gs.info('CSK incidents' + JSON.stringify(incidents) );
        */

        gs.info("CSK items" + JSON.stringify(pollUtil.getItems()));


        /*https://dev288390.service-now.com/images/icons/save.gifx
        		var importSet = new GlideRecord('sys_import_set');
        		importSet.short_description = 'Import set from scripted rest api';
        		importSet.table_name = importSetTableName;
        		var importSetID = importSet.insert();
        		var transformMapId = '<sys id of transform map>';
        		var transformer = new GlideImportSetTransformer();
        		transformer.setMapID(transformMapId);
        		transformer.transformAllMaps(importSet);
        		*/
    }
};
PollUtil.prototype = {

	createImportRows: function(incidents) {
		/*
<x_376096_tpoll_task_poll_int_incident>
...
<u_attachments/>
<u_comments>4</u_comments>
<u_description>4</u_description>
<u_impact/>
<u_number>0000004</u_number>
<u_priority/>
<u_remote_sys_id>d5068add-f194-4fc9-b6e7-df685c021b9e</u_remote_sys_id>
<u_short_description>4</u_short_description>
<u_state/>
<u_urgency/>
<u_work_notes>4</u_work_notes>
</x_376096_tpoll_task_poll_int_incident>
*/
	},

    syncAll: function(aliasSysID) {
        const lastUpdateTime = this.getLastUpdateTime(aliasSysID);

        const incidents = {
            /*
            "<remote incident sys id>": {
            	remote_incident: {
            		sys_id: "remote inc sys_id",
            		short_description: "remote inc short description",
            		description: "remote inc description",
            		state: 5,
            		comments: [],
            		work_notes: [],
            		attachments: [] 
            	},
            	incident_task: [{
            		sys_id: "remote inc sys_id",
            		work_notes: [],
            		comments: [{
            			sys_created_by: "remote user_name",
            			value: "comment or work note"
            		}],
            		attachments: []
            	}]
            }*/
        };
        this._request([
            // get incident status updates (because we have read access to closed incident_tasks) and private communications
            this._prepareTableAPI({
                table: 'incident_task',
                query: 'sys_updated_on>=' + lastUpdateTime,
                fields: ['sys_id', 'state', 'incident', 'incident.state'],
                callback: function(resp) {
                    // process all known incident tasks
                    resp.result.forEach(incTask => {
                        if (incTask.incident) {
                            incidents[incTask.incident] ??= {
                                remote_incident: {
                                    state: incTask['incident.state']
                                },
                                incident_task: []
                            };

                            incidents[incTask.incident].push(incTask);
                        } else {
                            const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
                            m2mID.addQuery('remote_id', 'incident_task|' + incTask.sys_id);
                            m2mID.orderByDesc('sys_created_on');
                            m2mID.setLimit(1);
                            m2mID.query();
                            if (m2mID.next()) {
                                // we have seen this incident task before
                                const m2mID2 = new GlideRecord('x_376096_tpoll_m2m_id');
                                m2mID2.addQuery('local_id', m2mID.local_id);
                                m2mID2.addQuery('remote_id', 'STARTSWITH', 'incident|');
                                m2mID2.orderByDesc('sys_created_on');
                                m2mID2.setLimit(1);
                                m2mID2.query();
                                if (m2mID2.next()) {
                                    const remoteIncSysID = m2mID2.remote_id.toString().substring('incident|'.length);
                                    incidents[m2mID2.remote_id.toString().substring('incident|'.length)] ??= {
                                        remote_incident: {
                                            state: null
                                        },
                                        incident_task: []
                                    };

                                    incidents[incTask.incident].incident_task.push(incTask);
                                } else {
                                    // we have seen the incident task but not the incident itself? edge case: create an incident
                                    // the inc could be created during transformation as well 
                                    // but here is easier to save the inc sys_id into the m2m local_id
                                    const incGr = new GlideRecord('incident');
                                    incGr.initialize();
                                    incGr.insert();

                                    m2mID.local_id = incGr.sys_id;
                                    m2mID.update();

                                    incidents[incTask.incident].incident_task.push(incTask);
                                }
                            } else {
                                // inc task has not yet been seen, but we have no access to the inc => ignore the incident as the service desk has nothing to handle
                            }
                        }
                    });
                }
            }),
            this._prepareTableAPI({
                table: 'incident',
                // get all incident which have been either updated since we last synced, or for which a incident_task we can read was created retrospectively
                query: 'sys_updated_on>=' + lastUpdateTime + '^NQsys_updated_on<' + lastUpdateTime + '^RLQUERYincident_task.incident,=1^sys_created_on>=' + lastUpdateTime,
                fields: ['sys_id', 'state'],
                callback: function(resp) {
                    resp.result.forEach(inc => {
                        const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
                        m2mID.addQuery('remote_id', 'incident|' + inc.sys_id);
                        m2mID.orderByDesc('sys_created_on');
                        m2mID.setLimit(1);
                        m2mID.query();
                        if (!m2mID.next()) {
                            // new incident, create and record into the m2m table
                            const incGr = new GlideRecord('incident');
                            incGr.initialize();
                            incGr.insert();

                            const newM2mID = new GlideRecord('x_376096_tpoll_m2m_id');
                            newM2mID.remote_id = 'incident|' + inc.sys_id;
                            newM2mID.local_id = incGr.sys_id.toString();
                            newM2mID.insert();
                        }
                        incidents[inc.sys_id.toString()] ??= {
                            remote_incident: {
                                sys_id: inc.sys_id,
                                state: inc.state,
                                short_description: inc.short_description,
                                description: inc.description,
                                comments: [],
                                work_notes: [],
                                attachments: []
                            },
                            incident_task: []
                        };

                    });
                }
            }),
            this._prepareTableAPI({
                table: 'incident',
                // get all incident which have been either updated since we last synced, or for which a incident_task we can read was created retrospectively
                query: 'sys_updated_on<' + lastUpdateTime + '^RLQUERYincident_task.incident,=1^sys_created_on>=' + lastUpdateTime,
                fields: ['sys_id', 'state'],
                callback: function(resp) {
                    resp.result.forEach(inc => {
                        const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
                        m2mID.addQuery('remote_id', 'incident|' + inc.sys_id);
                        m2mID.orderByDesc('sys_created_on');
                        m2mID.setLimit(1);
                        m2mID.query();
                        if (!m2mID.next()) {
                            // new incident, create and record into the m2m table
                            const incGr = new GlideRecord('incident');
                            incGr.initialize();
                            incGr.insert();

                            const newM2mID = new GlideRecord('x_376096_tpoll_m2m_id');
                            newM2mID.remote_id = 'incident|' + inc.sys_id;
                            newM2mID.local_id = incGr.sys_id.toString();
                            newM2mID.insert();
                        }
                        incidents[inc.sys_id.toString()] ??= {
                            remote_incident: {
                                sys_id: inc.sys_id,
                                state: inc.state,
                                short_description: inc.short_description,
                                description: inc.description,
                                comments: [],
                                work_notes: [],
                                attachments: []
                            },
                            incident_task: []
                        };

                    });
                }
            }),
            this._prepareTableAPI({
                table: 'sys_journal_field',
                query: 'name=incident^ORname=incident_task^sys_created_on>=' + lastUpdateTime,
                fields: ['sys_id', 'element_id', 'value', 'name'],
                callback: function(resp) {
                    resp.result.forEach(journal => {
                        var externalInc = incidents[journal.element_id];
                        if (externalInc) {
                            externalInc.remote_incident.work_notes.push(journal.value);
                        }
                    });
                }
            }),
            this._prepareTableAPI({
                table: 'sys_attachment',
                query: 'table_name=incident^ORtable_name=incident_task^sys_created_on>=' + lastUpdateTime,
                fields: ['table_name', 'sys_id', 'table_sys_id', 'file_name', 'size_bytes'],
                callback: function(resp) {
                    resp.result.forEach(att => {
                        if (att.table_name == 'incident') {
                            const externalIncForJournal = incidents[att.table_sys_id];
                            if (externalIncForJournal) {
                                externalIncForJournal.remote_incident.attachments.push({
                                    table: att.table_name,
                                    sys_id: att.sys_id,
                                    fileName: att.file_name
                                });
                            }
                        } else if (att.table_name == 'incident_task') {
                            const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
                            m2mID.addQuery('remote_id', 'incident_task|' + att.table_sys_id);
                            m2mID.orderByDesc('sys_created_on');
                            m2mID.setLimit(1);
                            m2mID.query();
                            if (m2mID.next()) {
                                const m2mID2 = new GlideRecord('x_376096_tpoll_m2m_id');
                                m2mID2.addQuery('remote_id', 'incident|' + m2mID2.remote_id.toString().substring('incident_task|'.length));
                                m2mID2.orderByDesc('sys_created_on');
                                m2mID2.setLimit(1);
                                m2mID2.query();
                                if (m2mID2.next()) {
                                    const externalIncForAtt = incidents[m2mID2.remote_id.toString().substring('incident|'.length)];
                                    if (externalIncForAtt) {
                                        externalIncForAtt.remote_incident.attachments.push({
                                            table: att.table_name,
                                            sys_id: att.sys_id,
                                            fileName: att.file_name
                                        });
                                    }
                                }
                            }
                        }
                    });
                }
            })
        ]);
    },
    initialize: function(connAliasSysID) {
        this.connAliasSysID = connAliasSysID;
        this.connInfo = new sn_cc.ConnectionInfoProvider().getConnectionInfo(connAliasSysID);
        this.connURL = this.connInfo.getAttribute('connection_url');
        if (!this.connURL.endsWith('/')) {
            this.connURL += '/';
        }

        const credentials = new sn_cc.StandardCredentialsProvider().getCredentialByAliasID(connAliasSysID);
        const type = credentials.getAttribute('type');
        if (type == 'oauth_2_0') {
            const credSysID = credentials.getAttribute('sys_id');
            const profileGr = new GlideRecord('oauth_requestor_profile');
            profileGr.addQuery('requestor_context', 'oauth_2_0_credentials');
            profileGr.addQuery('requestor_id', credSysID);
            profileGr.setLimit(1);
            profileGr.query();
            if (profileGr.next()) {
                const oAuthInfo = {
                    authenticationProfile: {
                        type: 'oauth2',
                        profileId: profileGr.getValue('oauth_entity_profile')
                    },
                    requestorProfile: {
                        requestorContext: 'oauth_2_0_credentials',
                        requestorId: credSysID
                    }
                };

                this._authReq = function(req) {
                    req.setAuthenticationProfile(oAuthInfo.authenticationProfile.type, oAuthInfo.authenticationProfile.profileId);
                    if (oAuthInfo.requestorProfile) {
                        req.setRequestorProfile(this.authInfo.requestorProfile.requestorContext, this.authInfo.requestorProfile.requestorId);
                    }
                };
            }
        } else if (type == 'basic_auth') {
            const basicAuthInfo = {
                username: credentials.getAttribute('user_name'),
                password: credentials.getAttribute('password')
            };

            this._authReq = function(req) {
                req.setBasicAuth(basicAuthInfo.username, basicAuthInfo.password);
            };
        } else if (type == 'api_key') {
            const apiKey = credentials.getAttribute('api_key');
            this._authReq = function(req) {
                req.setRequestHeader('Authorization', 'Bearer ' + apiKey);
            };
        }

        if (!this._authReq) {
            throw new Error('Unhandled or incomplete credential: ' + type);
        }
    },

    getItems: function() {
        let incidents = this.getRecords2("table/incident");
        let incidentTasks = this.getRecords2("table/incident_task");
        let attachments = this.getRecords2("attachment");
        let journalFields = this.getRecords2("table/sys_journal_field");

        let dte = gs.dateGenerate('2025-01-12', '12:11:23');
        let incTasks = this.prepareTableAPI({
            table: 'table//incident_task',
            query: ['active=true^sys_updated_on>=' + dte],
            fields: ['sys_id']
        });

        incTasks.callback = function(intTaskSysIds) {
            let sysIdList = String.join(intTaskSysIds, ',');
            let incTaskGr = new GlideRecord('x_376096_tpoll_m2m_id');
            incTaskGr.addQuery('remote_id', 'IN', sysIdList);
            incTaskGr.query();
            let existingItems = [];
            while (incTaskGr.next()) {
                let currentSysId = incTaskGr.sys_id;
                existingItems.push(currentSysId);
                sysIdList.replace(currentSysId, '');
            }
        };

        let result = this.getRecords3([incTasks]);

        return {
            status: "success",
            incidents: incidents,
            incidentTasks: incidentTasks,
            attachments: attachments,
            journalFields: journalFields,
        };
    },

    getRecords3: function(preparedRequests) {
        for (var idx in preparedRequests) {
            var rq = preparedRequests[idx];
            let req = this.getRecords2(rq.table, rq.query, rq.fields, rq.limit);
            if (req.status == 'error') {
                return req;
            }
            rq.callback(req.records);
        }
    },

    getRecords2: function(table, query, fields, limit) {
        limit = 300;
        let req = new sn_ws.RESTMessageV2();
        req.setRequestHeader("Accept", "application/json");
        req.setRequestHeader("Content-Type", "application/json");
        req.setBasicAuth("admin", "hDz/*9N2vjDY");

        let url = table;

        const params = [];
        if (query) {
            params.push("sysparm_query=" + encodeURIComponent(query));
        }

        if (limit) {
            params.push("sysparm_limit=" + limit);
        }

        if (fields) {
            params.push("sysparm_fields=" + encodeURIComponent(fields.join(",")));
        }

        if (params.length) {
            url += "?" + params.join("&");
        }

        req.setHttpMethod('GET');
        req.setEndpoint(this.connURL + url);

        const resp = req.execute();
        if (resp.haveError() || resp.getStatusCode() != "200") {
            return {
                status: "error",
                message: resp.getErrorMessage(),
                code: resp.getErrorCode(),
            };
        }
        const respBody = resp.getBody();
        const records = JSON.parse(respBody)?.result ?? [];


        return {
            status: "success",
            records: records,
        };
    },

    /**
     * @param {{
     * 	headers: object<string,string>[],
     *  url: string, 
     *  method: 'get'|'post'|'put'
     * }[]} preparedRequests
     */
    _request: function(preparedRequests) {
        for (let i = 0; i < preparedRequests.length; i++) {
            const preparedReq = preparedRequests[i];
            preparedReq.id = i + 1;
            if (preparedReq.body) {
                preparedReq.body = gs.base64Encode(preparedReq.body);
            }
        }

        let req = new sn_ws.RESTMessageV2();
        req.setRequestHeader('Accept', 'application/json');
        req.setRequestHeader('Content-Type', 'application/json');
        req.setHttpMethod('GET');
        req.setRequestBody(JSON.stringify({
            batch_request_id: 1,
            rest_requests: preparedRequests
        }));

        const resp = req.execute();
        if (resp.haveError()) {

            return {
                status: 'error',
                message: resp.getErrorMessage(),
                code: resp.getErrorCode()
            };
        }

        const requests = JSON.parse(resp.getBody()).serviced_requests;
        for (let i = 0; i < preparedRequests.length; i++) {
            const preparedReq = preparedRequests[i];
            const reqResp = requests.find(req => req.id == preparedReq.id);
            preparedReq?.callback(gs.base64Decode(reqResp.body));
        }

        return {
            status: 'success',
            requests: requests
        };
    },

    getRecords: function({
        table,
        query,
        limit = 10
    }) {
        // 1: new incs -> alle INCs die wir noch nicht kennen
        //    identifizierbar über sys_created_on>last_sync_date?
        //    neue incs bedeutet wir haben incident tasks!
        // 2: updated incs -> sys_created_on<=last_sync_date^sys_updated_on>last_sync_date
        // 3: closed incs -> remote_sys_id aller bekannten INCs sammeln => active=true^sys_idIN<liste>

        let incReq = this.prepareTableAPI({
            id: 1,
            table: table,
            query: query,
            limit: limit
        });

        let req = new sn_ws.RESTMessageV2();
        req.setRequestHeader('Accept', 'application/json');
        req.setRequestHeader('Content-Type', 'application/json');
        req.setHttpMethod(incReq.method);


        let ep = this.connURL + incReq.url;
        req.setEndpoint(ep);

        const resp = req.execute();
        if (resp.haveError() || resp.getStatusCode() != '200') {

            return {
                status: 'error',
                message: resp.getErrorMessage(),
                code: resp.getErrorCode()
            };
        }
        const respBody = resp.getBody();
        const incidents = JSON.parse(respBody)?.result ?? [];
        /*
		req.setRequestBody(JSON.stringify({
			batch_request_id: 1,
			rest_requests: [
				this.prepareTableAPI({
					id: 1,
					table: table,
					query: query,
					limit: limit
				}),
				this.prepareTableAPI({
					id: 2,
					table: 'sys_journal_field'
				}),
				this.prepareTableAPI({
					id: 3,
					table: 'sys_attachment',
					fields: ['sys_id']
				})
			]
		}));
	
		const resp = req.execute();
		if (resp.haveError()) {
	
			return {
				status: 'error',
				message: resp.getErrorMessage(),
				code: resp.getErrorCode()
			};
		}
	
		let rb = resp.getBody();
		gs.info('CSK RESP ' + rb );
	
		const requests = JSON.parse(rb).serviced_requests;
		let incidents = requests.find(req => req.id == 1);
		let journalFields = requests.find(req => req.id == 2);
		let attachments = requests.find(req => req.id == 3);
	
		gs.info('CSK incidents.body ' + incidents.body);
		gs.info('CSK incidents.body 2' + gs.base64Decode(incidents.body));
	
		if (incidents?.status_text != 'OK' ) { // || journalFields?.status_text != 'OK' || attachments?.status_text != 'OK') {
			return {
				status: 'error',
				message: 'Failed to retrieve incidents, journal_fields or attachments'
			};
		}
	
		gs.info('CSK incidents.body 3' + incidents.body);
		gs.info('CSK incidents.body 4' + gs.base64Decode(incidents.body));
		incidents = JSON.pars(gs.base64Decode(incidents.body));
		const incMap = {};
		incidents.forEach(inc => {
			inc.attachments = [];
			incMap[inc.sys_id] = inc;
		});
	
		journalFields = gs.base64Decode(journalFields.body);
		journalFields.forEach(jf => {
			const inc = incMap[jf.element_id];
			if (inc) {
				(inc[jf.element] ??= []).push(jf);
			}
		});
	
		attachments = gs.base64Decode(attachments.body);
		attachments.forEach(att => incidents.attachments.push(att));
		*/

        return {
            status: 'success',
            records: incidents
        };
    },

    _prepareTableAPI: function({
        table,
        query,
        fields,
        limit,
        offset,
        callback
    }) {
        const params = [];
        if (query) {
            params.push('sysparm_query=' + encodeURIComponent(query));
        }

        if (limit) {
            params.push('sysparm_limit=' + limit);
        }

        if (offset) {
            params.push('sysparm_offset=' + offset);
        }

        if (fields?.length) {
            params.push('sysparm_fields=' + encodeURIComponent(fields.join(',')));
        }

        let url = 'api/now/table/' + table;
        if (params.length) {
            url += '?' + params.join('&');
        }

        return {
            headers: [{
                name: 'Content-Type',
                value: 'application/json'
            }, {
                name: 'Accept',
                value: 'application/json'
            }],
            url: url,
            method: 'GET',
            callback: callback
        };
    },

    type: 'PollUtil'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2025-01-08 12:55:10</sys_created_on>
        <sys_id>c8ed32d083831210f6ed55e0deaad30c</sys_id>
        <sys_mod_count>46</sys_mod_count>
        <sys_name>PollUtil</sys_name>
        <sys_package display_value="Task Poll" source="x_376096_tpoll">8d4a0b53835212100971c810feaad3d9</sys_package>
        <sys_policy/>
        <sys_scope display_value="Task Poll">8d4a0b53835212100971c810feaad3d9</sys_scope>
        <sys_update_name>sys_script_include_c8ed32d083831210f6ed55e0deaad30c</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-01-14 18:19:15</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>c8ed32d083831210f6ed55e0deaad30c</id>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2025-01-08 12:55:09</sys_created_on>
        <sys_id>a8074bdc83831210f6ed55e0deaad3b3</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>markus.kraus</sys_updated_by>
        <sys_updated_on>2025-01-08 12:55:09</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
