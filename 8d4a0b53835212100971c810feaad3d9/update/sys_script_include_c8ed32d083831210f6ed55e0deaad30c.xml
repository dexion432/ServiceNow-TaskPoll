<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_376096_tpoll.PollUtil</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>TODO f端r 15.01: &#13;
1.) basic API per background script verifizieren: this._request in verbindung mit this._prepareTableAPI auf eine instanz der wahl&#13;
2.) den m2m lookup generalisieren (single function)&#13;
3.) import set erstellung: d.h. importset erzeugen und inserts in the tpoll incident tabelle machen&#13;
</description>
        <mobile_callable>false</mobile_callable>
        <name>PollUtil</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global Class, gs, sn_cc, sn_ws, x_376096_tpoll */
/* global GlideRecord, GlideDateTime */
/* eslint no-undef: "error" */
var PollUtil = Class.create();
PollUtil.syncAll = function () {
	const aliasGr = new GlideRecord('sys_alias');
	aliasGr.addQuery('parent.id', 'x_376096_tpoll.tpoll');
	aliasGr.query();
	while (aliasGr.next()) {
		const pollUtil = new x_376096_tpoll.PollUtil(aliasGr.getUniqueValue());
		/*
		const incidents = pollUtil.getRecords({
			table: 'incident'
		});

		gs.info('CSK incidents' + JSON.stringify(incidents) );
		*/

		gs.info("CSK items" + JSON.stringify(pollUtil.getItems()));


		/*https://dev288390.service-now.com/images/icons/save.gifx
				var importSet = new GlideRecord('sys_import_set');
				importSet.short_description = 'Import set from scripted rest api';
				importSet.table_name = importSetTableName;
				var importSetID = importSet.insert();
				var transformMapId = '<sys id of transform map>';
				var transformer = new GlideImportSetTransformer();
				transformer.setMapID(transformMapId);
				transformer.transformAllMaps(importSet);
				*/
	}
};
PollUtil.prototype = {

	createImportRows: function (incidents) {
		/*
<x_376096_tpoll_task_poll_int_incident>
...
<u_attachments/>
<u_comments>4</u_comments>
<u_description>4</u_description>
<u_impact/>
<u_number>0000004</u_number>
<u_priority/>
<u_remote_sys_id>d5068add-f194-4fc9-b6e7-df685c021b9e</u_remote_sys_id>
<u_short_description>4</u_short_description>
<u_state/>
<u_urgency/>
<u_work_notes>4</u_work_notes>
</x_376096_tpoll_task_poll_int_incident>
*/
	},
	getLastUpdateTime: function () { return this._lastUpdatedTime; },		
	syncIncidents: function () {
		const lastUpdateTime = this.getLastUpdateTime();

		const incidents = {
			/*
			"<remote incident sys id>": {
				remote_incident: {
					sys_id: "remote inc sys_id",
					short_description: "remote inc short description",
					description: "remote inc description",
					state: 5,
					comments: [],
					work_notes: [],
					attachments: [] 
				},
				incident_task: [{
					sys_id: "remote inc sys_id",
					work_notes: [],
					comments: [{
						sys_created_by: "remote user_name",
						value: "comment or work note"
					}],
					attachments: []
				}]
			}*/
		};
		this._request([
			// get incident status updates (because we have read access to closed incident_tasks) and private communications
			this._prepareTableAPI({
				table: 'incident_task',
				query: 'sys_updated_on>=' + lastUpdateTime,
				fields: ['sys_id', 'state', 'incident', 'incident.state'],
				callback: function (resp) {
					// process all known incident tasks
					resp.result.forEach(incTask => {
						if (incTask.incident) {
							incidents[incTask.incident] ??= {
								remote_incident: {
									state: incTask['incident.state']
								},
								incident_task: []
							};

							incidents[incTask.incident].push(incTask);
						} else {
							const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
							m2mID.addQuery('remote_id', incTask.sys_id);
							m2mID.orderByDesc('sys_created_on');
							m2mID.setLimit(1);
							m2mID.query();
							if (m2mID.next()) {
								if (m2mID.metadata.remote_incident) {
									incidents[m2mID.metadata.remote_incident] ??= {
										remote_incident: {
											// the remote incident task was unable to read the incident state - this identifies closed incidents
											state: null
										},
										incident_task: []
									};

									incidents[incTask.incident].incident_task.push(incTask);									
								} else {
									// we have seen the incident task but not the incident itself? edge case: create an incident
									// the inc could be created during transformation as well 
									// but here is easier to save the inc sys_id into the m2m local_id
									// MKR: the transform could very well decide not to create incidents, but cases instead
									const incGr = new GlideRecord('incident');
									incGr.initialize();
									incGr.insert();

									m2mID.local_id = incGr.sys_id;
									m2mID.update();

									incidents[incTask.incident].incident_task.push(incTask);
								}
							} else {
								// inc task has not yet been seen, but we have no access to the inc => ignore the incident as the service desk has nothing to handle
							}
						}
					});
				}
			}),
			this._prepareTableAPI({
				table: 'incident',
				// get all incident which have been either updated since we last synced, or for which a incident_task we can read was created retrospectively
				query: 'sys_updated_on>=' + lastUpdateTime + '^NQsys_updated_on<' + lastUpdateTime + '^RLQUERYincident_task.incident,=1^sys_created_on>=' + lastUpdateTime,
				fields: ['sys_id', 'state'],
				callback: function (resp) {
					resp.result.forEach(inc => {
						/*
						// MKR: entfernt, wir d端rfen an dieser stelle weder m2m noch inc/inc task erstellen
						// es ist die aufgabe der transform map das zu machen
						// die einzige annahme die wir vom transform layer haben ist, dass local ein task-type erzeugt wird
						// und dass das daten-interface der m2m respektiert wird
						const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
						m2mID.addQuery('remote_id', 'incident|' + inc.sys_id);
						m2mID.orderByDesc('sys_created_on');
						m2mID.setLimit(1);
						m2mID.query();
						if (!m2mID.next()) {
							// new incident, create and record into the m2m table
							const incGr = new GlideRecord('incident');
							incGr.initialize();
							incGr.insert();

							const newM2mID = new GlideRecord('x_376096_tpoll_m2m_id');
							newM2mID.remote_id = 'incident|' + inc.sys_id;
							newM2mID.local_id = incGr.sys_id.toString();
							newM2mID.insert();
						}*/
						incidents[inc.sys_id.toString()] ??= {
							remote_incident: {
								sys_id: inc.sys_id,
								state: inc.state,
								short_description: inc.short_description,
								description: inc.description,
								comments: [],
								work_notes: [],
								attachments: []
							},
							incident_task: []
						};

					});
				}
			}),
			this._prepareTableAPI({
				table: 'incident',
				// get all incident which have been either updated since we last synced, or for which a incident_task we can read was created retrospectively
				query: 'sys_updated_on<' + lastUpdateTime + '^RLQUERYincident_task.incident,=1^sys_created_on>=' + lastUpdateTime,
				fields: ['sys_id', 'state'],
				callback: function (resp) {
					resp.result.forEach(remoteInc => {
						/*
						// MKR: auskommentiert da wir hier keine transform logic machen.
						// wir d端rfen an dieser stelle auch keine insert in die m2m machen, denn die d端rfen nur passieren
						// wenn die transform map sich entschieden hat einen incident/inc task / case / ... zu erstellen
						const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
						m2mID.addQuery('remote_id', 'incident|' + inc.sys_id);
						m2mID.orderByDesc('sys_created_on');
						m2mID.setLimit(1);
						m2mID.query();
						if (!m2mID.next()) {
							// new incident, create and record into the m2m table
							const incGr = new GlideRecord('incident');
							incGr.initialize();
							incGr.insert();

							const newM2mID = new GlideRecord('x_376096_tpoll_m2m_id');
							newM2mID.remote_id = inc.sys_id;
							newM2mID.local_id = incGr.sys_id.toString();
							newM2mID.insert();
						}*/
						incidents[remoteInc.sys_id.toString()] ??= {
							remote_incident: {
								sys_id: remoteInc.sys_id,
								state: remoteInc.state,
								short_description: remoteInc.short_description,
								description: remoteInc.description,
								comments: [],
								work_notes: [],
								attachments: []
							},
							incident_task: []
						};

					});
				}
			}),
			this._prepareTableAPI({
				table: 'sys_journal_field',
				query: 'name=incident^ORname=incident_task^sys_created_on>=' + lastUpdateTime,
				fields: ['sys_id', 'element_id', 'value', 'name'],
				callback: function (resp) {
					resp.result.forEach(journal => {
						var externalInc = incidents[journal.element_id];
						if (externalInc) {
							externalInc.remote_incident.work_notes.push(journal.value);
						}
					});
				}
			}),
			this._prepareTableAPI({
				table: 'sys_attachment',
				query: 'table_name=incident^ORtable_name=incident_task^sys_created_on>=' + lastUpdateTime,
				fields: ['table_name', 'sys_id', 'table_sys_id', 'file_name', 'size_bytes'],
				callback: function (resp) {
					resp.result.forEach(att => {
						if (att.table_name == 'incident') {
							const externalIncForJournal = incidents[att.table_sys_id];
							if (externalIncForJournal) {
								externalIncForJournal.remote_incident.attachments.push({
									table: att.table_name,
									sys_id: att.sys_id,
									fileName: att.file_name
								});
							}
						} else if (att.table_name == 'incident_task') {
							// an external incident_task is always synced into the local task
							const m2mID = new GlideRecord('x_376096_tpoll_m2m_id');
							m2mID.addQuery('remote_id', att.table_sys_id);
							m2mID.orderByDesc('sys_created_on');
							m2mID.setLimit(1);
							m2mID.query();
							if (m2mID.next()) {
								const externalIncForAtt = incidents[m2mID.metdata.remote_incident];
								if (externalIncForAtt) {
									externalIncForAtt.remote_incident.attachments.push({
										table: att.table_name,
										sys_id: att.sys_id,
										fileName: att.file_name
									});
								}
								/*const m2mID2 = new GlideRecord('x_376096_tpoll_m2m_id');
								m2mID2.addQuery('remote_id', 'incident|' + m2mID2.remote_id.toString().substring('incident_task|'.length));
								m2mID2.orderByDesc('sys_created_on');
								m2mID2.setLimit(1);
								m2mID2.query();
								if (m2mID2.next()) {
									const externalIncForAtt = incidents[m2mID2.remote_id.toString().substring('incident|'.length)];
									if (externalIncForAtt) {
										externalIncForAtt.remote_incident.attachments.push({
											table: att.table_name,
											sys_id: att.sys_id,
											fileName: att.file_name
										});
									}
								}*/
							}
						}
					});
				}
			})
		]);
	},
	initialize: function (connAliasSysID) {
		const importRowGr = new GlideRecord('x_376096_tpoll_task_poll_int_incident');
		importRowGr.addQuery('x_376096_tpoll_m2m_id', connAliasSysID);
		importRowGr.orderByDesc('sys_updated_on');
		importRowGr.setLimit(1);
		if (importRowGr.next()) {
			this._lastUpdatedTime = new GlideDateTime(importRowGr.sys_updated_on);
		} else {
			this._lastUpdatedTime = new GlideDateTime('1970-01-01 00:00:00');
		}

		this.connAliasSysID = connAliasSysID;
		this.connInfo = new sn_cc.ConnectionInfoProvider().getConnectionInfo(connAliasSysID);
		this.connURL = this.connInfo.getAttribute('connection_url');
		if (!this.connURL.endsWith('/')) {
			this.connURL += '/';
		}

		const credentials = new sn_cc.StandardCredentialsProvider().getCredentialByAliasID(connAliasSysID);
		const type = credentials.getAttribute('type');
		if (type == 'oauth_2_0') {
			const credSysID = credentials.getAttribute('sys_id');
			const profileGr = new GlideRecord('oauth_requestor_profile');
			profileGr.addQuery('requestor_context', 'oauth_2_0_credentials');
			profileGr.addQuery('requestor_id', credSysID);
			profileGr.setLimit(1);
			profileGr.query();
			if (profileGr.next()) {
				const oAuthInfo = {
					authenticationProfile: {
						type: 'oauth2',
						profileId: profileGr.getValue('oauth_entity_profile')
					},
					requestorProfile: {
						requestorContext: 'oauth_2_0_credentials',
						requestorId: credSysID
					}
				};

				this._authReq = function (req) {
					req.setAuthenticationProfile(oAuthInfo.authenticationProfile.type, oAuthInfo.authenticationProfile.profileId);
					if (oAuthInfo.requestorProfile) {
						req.setRequestorProfile(this.authInfo.requestorProfile.requestorContext, this.authInfo.requestorProfile.requestorId);
					}
				};
			}
		} else if (type == 'basic_auth') {
			const basicAuthInfo = {
				username: credentials.getAttribute('user_name'),
				password: credentials.getAttribute('password')
			};

			this._authReq = function (req) {
				req.setBasicAuth(basicAuthInfo.username, basicAuthInfo.password);
			};
		} else if (type == 'api_key') {
			const apiKey = credentials.getAttribute('api_key');
			this._authReq = function (req) {
				req.setRequestHeader('Authorization', 'Bearer ' + apiKey);
			};
		}

		if (!this._authReq) {
			throw new Error('Unhandled or incomplete credential: ' + type);
		}
	},

	/**
	 * @param {{
	 * 	headers: object<string,string>[],
	 *  url: string, 
	 *  method: 'get'|'post'|'put'
	 * }[]} preparedRequests
	 */
	_request: function (preparedRequests) {
		// prepare for batch api
		for (let i = 0; i < preparedRequests.length; i++) {
			const preparedReq = preparedRequests[i];
			preparedReq.id = i + 1;
			if (preparedReq.body) {
				preparedReq.body = gs.base64Encode(preparedReq.body);
			}
		}

		let req = new sn_ws.RESTMessageV2();
		req.setRequestHeader('Accept', 'application/json');
		req.setRequestHeader('Content-Type', 'application/json');
		req.setHttpMethod('GET');
		req.setRequestBody(JSON.stringify({
			batch_request_id: 1,
			rest_requests: preparedRequests
		}));

		this._authReq(req);
		const resp = req.execute();
		if (resp.haveError()) {

			return {
				status: 'error',
				message: resp.getErrorMessage(),
				code: resp.getErrorCode()
			};
		}

		const requests = JSON.parse(resp.getBody()).serviced_requests;
		for (let i = 0; i < preparedRequests.length; i++) {
			const preparedReq = preparedRequests[i];
			const reqResp = requests.find(req => req.id == preparedReq.id);
			preparedReq?.callback(gs.base64Decode(reqResp.body));
		}

		return {
			status: 'success',
			requests: requests
		};
	},

	_prepareTableAPI: function ({
		table,
		query,
		fields,
		limit,
		offset,
		callback
	}) {
		const params = [];
		if (query) {
			params.push('sysparm_query=' + encodeURIComponent(query));
		}

		if (limit) {
			params.push('sysparm_limit=' + limit);
		}

		if (offset) {
			params.push('sysparm_offset=' + offset);
		}

		if (fields?.length) {
			params.push('sysparm_fields=' + encodeURIComponent(fields.join(',')));
		}

		let url = 'api/now/table/' + table;
		if (params.length) {
			url += '?' + params.join('&');
		}

		return {
			headers: [{
				name: 'Content-Type',
				value: 'application/json'
			}, {
				name: 'Accept',
				value: 'application/json'
			}],
			url: url,
			method: 'GET',
			callback: callback
		};
	},

	type: 'PollUtil'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2025-01-08 12:55:10</sys_created_on>
        <sys_id>c8ed32d083831210f6ed55e0deaad30c</sys_id>
        <sys_mod_count>49</sys_mod_count>
        <sys_name>PollUtil</sys_name>
        <sys_package display_value="Task Poll" source="x_376096_tpoll">8d4a0b53835212100971c810feaad3d9</sys_package>
        <sys_policy/>
        <sys_scope display_value="Task Poll">8d4a0b53835212100971c810feaad3d9</sys_scope>
        <sys_update_name>sys_script_include_c8ed32d083831210f6ed55e0deaad30c</sys_update_name>
        <sys_updated_by>markus.kraus</sys_updated_by>
        <sys_updated_on>2025-01-15 07:32:08</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>c8ed32d083831210f6ed55e0deaad30c</id>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2025-01-08 12:55:09</sys_created_on>
        <sys_id>a8074bdc83831210f6ed55e0deaad3b3</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>markus.kraus</sys_updated_by>
        <sys_updated_on>2025-01-08 12:55:09</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
